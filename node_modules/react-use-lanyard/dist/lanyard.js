"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useLanyard = void 0;
var tslib_1 = require("tslib");
var constants_1 = require("./constants");
var react_1 = require("react");
var swr_1 = tslib_1.__importDefault(require("swr"));
var useLanyard = function (options) {
    if (options.socket) {
        var _a = (0, react_1.useState)(), status_1 = _a[0], setStatus_1 = _a[1];
        var _b = (0, react_1.useState)(), websocket = _b[0], setWebsocket_1 = _b[1];
        var _c = (0, react_1.useState)(true), loading_1 = _c[0], setLoading_1 = _c[1];
        (0, react_1.useEffect)(function () {
            var supportsWebSocket = "WebSocket" in window || "MozWebSocket" in window;
            if (options.socket && !supportsWebSocket)
                throw new Error("Browser doesn't support WebSocket connections.");
            var subscription = typeof options.userId === "object"
                ? "subscribe_to_ids"
                : "subscribe_to_id";
            var heartbeat;
            var socket;
            var connectWebsocket = function () {
                if (heartbeat)
                    clearInterval(heartbeat);
                socket = new WebSocket(constants_1.WEBSOCKET_URL);
                setWebsocket_1(socket);
                setLoading_1(true);
                socket.addEventListener("open", function () {
                    var _a;
                    socket.send(JSON.stringify({
                        op: 2,
                        d: (_a = {},
                            _a[subscription] = options.userId,
                            _a),
                    }));
                    heartbeat = setInterval(function () {
                        socket.send(JSON.stringify({
                            op: 3,
                        }));
                    }, constants_1.HEARTBEAT_INTERVAL);
                });
                socket.addEventListener("message", function (_a) {
                    var data = _a.data;
                    var _b = JSON.parse(data), t = _b.t, d = _b.d;
                    if (t === "INIT_STATE" || t === "PRESENCE_UPDATE") {
                        setStatus_1(d || {});
                        if (loading_1)
                            setLoading_1(false);
                    }
                });
                socket.addEventListener("close", connectWebsocket);
            };
            connectWebsocket();
            return function () {
                clearInterval(heartbeat);
                socket.removeEventListener("close", connectWebsocket);
                socket.close();
            };
        }, []);
        return { websocket: websocket, loading: loading_1, status: status_1 };
    }
    else {
        if (typeof options.userId === "string") {
            return (0, swr_1.default)("lanyard_".concat(options.userId), function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
                var req, body;
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, fetch("".concat(constants_1.API_URL, "/users/").concat(options.userId))];
                        case 1:
                            req = _a.sent();
                            return [4 /*yield*/, req.json()];
                        case 2:
                            body = (_a.sent());
                            if (body.error)
                                throw new Error(body.error.message);
                            return [2 /*return*/, body];
                    }
                });
            }); });
        }
        else {
            return (0, swr_1.default)("lanyard_".concat(options.userId.join("_")), function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
                var responseArray, _i, _a, id, req, body;
                return tslib_1.__generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            responseArray = [];
                            _i = 0, _a = options.userId;
                            _b.label = 1;
                        case 1:
                            if (!(_i < _a.length)) return [3 /*break*/, 5];
                            id = _a[_i];
                            return [4 /*yield*/, fetch("".concat(constants_1.API_URL, "/users/").concat(id))];
                        case 2:
                            req = _b.sent();
                            return [4 /*yield*/, req.json()];
                        case 3:
                            body = (_b.sent());
                            if (body.error)
                                throw new Error(body.error.message);
                            responseArray.push(body);
                            _b.label = 4;
                        case 4:
                            _i++;
                            return [3 /*break*/, 1];
                        case 5: return [2 /*return*/, responseArray];
                    }
                });
            }); });
        }
    }
};
exports.useLanyard = useLanyard;
//# sourceMappingURL=lanyard.js.map